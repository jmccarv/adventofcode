package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

func main() {
	t0 := time.Now()
	input := bufio.NewScanner(os.Stdin)

	fh, err := os.Create("monkeys.go")
	if err != nil {
		panic(err)
	}
	defer fh.Close()

	fmt.Fprintf(fh, `// Code generated by elves, DO NOT EDIT.
package main

type monkey struct {
	nr int
	items []int
	op func(old int)
	inspected int
}

var p1monkeys []*monkey
var p2monkeys []*monkey

func init() {
`)
	var op, items, destTrue, destFalse string
	var divBy int
	lcm := 0
	x := 10
	monkey := -1

	for input.Scan() {
		if strings.HasPrefix(input.Text(), "Monkey") {
			monkey++
			x = 0
			continue
		}

		switch x {
		case 0: // starting items
			f := strings.Split(input.Text(), ":")
			items = f[1]
		case 1: // Operation
			f := strings.Split(input.Text(), "=")
			op = f[1]
		case 2: //test
			f := strings.Split(input.Text(), "by ")
			divBy, _ = strconv.Atoi(f[1])
			if lcm > 0 {
				lcm *= divBy
			} else {
				lcm = divBy
			}
		case 3: // If true
			f := strings.Fields(input.Text())
			destTrue = f[len(f)-1]
		case 4: // If false
			f := strings.Fields(input.Text())
			destFalse = f[len(f)-1]

			// we've read everything for the current monkey
			//fmt.Println("Monkey", monkey, items, op, divBy, destTrue, destFalse)
			fmt.Fprintf(fh, `
p1monkeys = append(p1monkeys, &monkey{
	nr: %d,
	items: []int{%s},
	op: func(old int) {
		old = (%s) / 3
		if old %% %d == 0 {
			p1monkeys[%s].items = append(p1monkeys[%s].items, old)
		} else {
			p1monkeys[%s].items = append(p1monkeys[%s].items, old)
		}
	},
})
p2monkeys = append(p2monkeys, &monkey{
	nr: %d,
	items: []int{%s},
	op: func(old int) {
		old = (%s) %% lcm
		if old %% %d == 0 {
			p2monkeys[%s].items = append(p2monkeys[%s].items, old)
		} else {
			p2monkeys[%s].items = append(p2monkeys[%s].items, old)
		}
	},
})
`, monkey, items, op, divBy, destTrue, destTrue, destFalse, destFalse,
				monkey, items, op, divBy, destTrue, destTrue, destFalse, destFalse)
		}
		x++
	}

	fmt.Fprintf(fh, `
}

var lcm = %d

`, lcm)

	fmt.Println("Generate:", time.Now().Sub(t0))
}
