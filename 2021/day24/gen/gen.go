package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

type register int

type operand struct {
	literal bool
	lval    int
	reg     string
}

type instruction struct {
	op   string
	args [2]operand
}

type instructions []instruction

var regMap map[string]bool

func init() {
	regMap = map[string]bool{
		"w": true,
		"x": true,
		"y": true,
		"z": true,
	}
}

func main() {
	var prg, block instructions
	var blocks []instructions

	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		s := strings.Fields(input.Text())
		prg.parseInstruction(s)
	}

	for _, i := range prg {
		switch i.op {
		case "inp":
			if len(block) > 0 {
				blocks = append(blocks, block)
			}
			block = instructions{}
		}
		block = append(block, i)
	}
	if len(block) > 0 {
		blocks = append(blocks, block)
	}

	if len(blocks) < 1 {
		panic("No input blocks")
	}

	fh, err := os.Create("blocks.go")
	if err != nil {
		panic(err)
	}
	defer fh.Close()

	fmt.Fprintln(fh, `// Code generated by elves, DO NOT EDIT.`)
	fmt.Fprintf(fh, "\npackage main\n\nimport \"sort\"\n\n")

	fmt.Fprintln(fh, `type register int

const (
	w register = iota
	x
	y
	z
)

`)

	fmt.Fprintf(fh, "func getBlocks() (blocks []func(inp int, s,n []state)) {\n")
	fmt.Fprintf(fh, "blocks = make([]func(inp int, s,n []state), 0, %d)\n", len(blocks))

	sorts := fmt.Sprintf("func getSorts() (sorts []func(ns stateList)) {\n")

	for _, block = range blocks {
		// first instruction is an inp
		if block[0].op != "inp" {
			panic("Invalid code block!")
		}

		ra := block[0].args[0].reg

		sorts += fmt.Sprintf(`sorts = append(sorts, func(ns stateList) {%s
				for i := range ns {
					ns[i].regs[%s] = 0
				}
				sort.Sort(ns)
		})%s`, "\n", ra, "\n")

		fmt.Fprintln(fh, "blocks = append(blocks, func(inp int, states, ns []state) {")

		fmt.Fprintf(fh, `
		for i := range states {
			ns[i] = states[i]
			ns[i].regs[%s] = inp
			ns[i].max = ns[i].max*10 + inp
			ns[i].min = ns[i].min*10 + inp
		}%s`, ra, "\n")

		fmt.Fprintln(fh, `for st := range ns {`)
		for _, i := range block[1:] {
			var ob string
			ra := i.args[0].reg

			if i.args[1].literal {
				ob = fmt.Sprintf("%d", i.args[1].lval)
			} else {
				ob = fmt.Sprintf("ns[st].regs[%s]", i.args[1].reg)
			}

			switch i.op {
			case "add":
				fmt.Fprintf(fh, "    ns[st].regs[%s] += %s\n", ra, ob)
			case "mul":
				fmt.Fprintf(fh, "    ns[st].regs[%s] *= %s\n", ra, ob)
			case "div":
				fmt.Fprintf(fh, "    ns[st].regs[%s] /= %s\n", ra, ob)
			case "mod":
				fmt.Fprintf(fh, "    ns[st].regs[%s] %%= %s\n", ra, ob)
			case "eql":
				fmt.Fprintf(fh, `
				if ns[st].regs[%s] == %s {
					ns[st].regs[%s] = 1
				} else {
					ns[st].regs[%s] = 0
				}%s`, ra, ob, ra, ra, "\n")
			}
		}
		fmt.Fprintf(fh, "}\n})\n")
	}
	fmt.Fprintf(fh, "return\n}\n")
	fmt.Fprintf(fh, "%sreturn\n}\n", sorts)
	return
}

func (p *instructions) parseInstruction(s []string) {
	var l2 int
	var err error
	var ok1, ok2 bool

	i := instruction{op: s[0]}

	if _, ok1 = regMap[s[1]]; !ok1 {
		panic(fmt.Sprintf("Invalid register '%s' for %v'", s[1], s))
	}

	i.args[0].reg = s[1]

	if len(s) > 2 {
		if l2, err = strconv.Atoi(s[2]); err == nil {
			ok2 = true
		}

		if ok2 {
			i.args[1].literal = true
			i.args[1].lval = l2
		} else {
			i.args[1].reg = s[2]
		}
	}
	*p = append(*p, i)
}
